"""
Provides several functions that employ dynamic programming
to find the longest common subsequence between two strings
"""

import itertools
from typing import List


def table(string_one: str, string_two: str) -> List[List[int]]:
    """
    For two strings, string_one of length i and string_two of length j,
    it produces a 2D-array such that the index[i][j] of the array is
    the length of the longest common subsequence between
    string_one[0:i+1] and string_two[0:j+1]

    Parameters:
        string_one (str): First string (length i)
        string_two (str): Second string (length j)

    Returns:
        List[List[int]: Dynamic programming array describing
                         longest subsequence length.
    """
    if not (string_one and string_two):
        return []
    tbl: List[List[int]] = [[None for j in range(len(string_two))]
                            for i in range(len(string_one))]
    for i, j in itertools.product(range(len(string_one)),
                                  range(len(string_two))):
        if i > 0 and j > 0:
            solution_one = int(string_one[i] == string_two[j]) \
                           + tbl[i - 1][j - 1]
        else:
            solution_one = int(string_one[i] == string_two[j])

        tbl[i][j] = max(solution_one,
                        tbl[i-1][j] if i > 0 else 0,
                        tbl[i][j-1] if j > 0 else 0)

    return tbl


def table_str(string_one: str, string_two: str) -> List[List[str]]:
    """
    Similar to table, except that it gives the longest subsequence
    as opposed to just the length of the longest subsequence.

    Parameters:
        string_one (str): First string (length i)
        string_two (str): Second string (length j)

    Returns:
        List[List[int]: Dynamic programming array describing
                         longest subsequence
    """
    if not (string_one and string_two):
        return []
    tbl: List[List[str]] = [[None for j in range(len(string_two))]
                            for i in range(len(string_one))]
    for i, j in itertools.product(range(len(string_one)),
                                  range(len(string_two))):
        if i > 0 and j > 0:
            solution_one = tbl[i-1][j-1] \
                           + string_one[i] if string_one[i] == string_two[j] \
                           else ""
        else:
            tbl[i][j] = string_one[i] if string_one[i] == string_two[j] else ""
            continue

        tbl[i][j] = max(solution_one,
                        (tbl[i-1][j] if i > 0 else ""),
                        (tbl[i][j-1] if j > 0 else ""),
                        key=len)

    return tbl


def match_length(tbl: List[List[int]]) -> int:
    """
    Takes in an output from table and returns the longest length

    Parameters:
        tbl (List[List[int]]): Table generated by table

    Returns:
        int: Length of longest subsequence
    """
    if not tbl:
        return 0
    return tbl[len(tbl) - 1][len(tbl[0]) - 1]


def match_string(string_one: str,
                 string_two: str,
                 tbl: List[List[int]]) -> str:
    """
    Determines the longest string from a table given (from the table function)
    that represents the longest common subsequence between string_one and
    string_two

    Parameters:
        string_one (str): First string (length i)
        string_two (str): Second string (length j)
        tbl (List[List[int]): Dynamic programming array describing
                              longest subsequence length.

    Returns:
        str: Longest common subsequence
    """
    if not tbl or not string_one or not string_two:
        return ""
    solution = ""
    for i in range(len(string_one)-1, 0, -1):
        if tbl[i-1][-1] < tbl[i][-1]:
            solution = string_one[i] + solution
    may_be_leading_characters = [string_one[i] for i in range(len(string_one))
                                 if tbl[i][-1] == 1]
    if may_be_leading_characters:
        while string_two[0] not in may_be_leading_characters:
            string_two = string_two[1:]
        return string_two[0] + solution
    return solution
